AIM:

To understand the basic commands in R programming.

PROCEDURE:

R as a calculator
> 1 + 2
[1] 3

Variable Assignment
We assign values to variables with the assignment operator "=". Just typing the variable by itself at the prompt will print out the value. We should note that another form of assignment operator "<-" is also in use.
> x = 1
>	x [1]
1

Functions
R functions are invoked by its name, then followed by the parenthesis, and zero or more arguments. The following apply the function c to combine three numeric values into a vector.

> c(1, 2, 3)
[1] 1 2 3

Comments
All text after the pound sign "#" within the same line is considered a comment.
>	1 + 1	# this is a comment
[1] 2

R Data Type
➢	Numeric
➢	Integer
➢	Complex
➢	Logical
➢	Character
Numeric:

Decimal values are called numeric sin R. It is the default computational data type. If we assign a decimal value to a variable x as follows, x will be of numeric type.
 

>	x = 10.5	# assign a decimal value
>	x	# print the value of x
[1] 10.5
>	class(x)	# print the class name of x
[1] "numeric"

Furthermore, even if we assign an integer to a variable k, it is still being saved as a numeric value.

> k = 1
>	k	# print the value of k
[1] 1
>	class(k)	# print the class name of k
[1] "numeric"
Integer:

In order to create an integer variable in R, we invoke the as.integerfunction. We can be assured that y is indeed an integer by applying the is.integer function.

>	y = as.integer(3)
>	y	# print the value of y
[1] 3
>	class(y)	# print the class name of y
[1] "integer"
>	is.integer(y) # is y an integer?
[1] TRUE

Incidentally, we can compel a numeric value into an integer with the same as.integerfunction.

>	as.integer(3.14)	# coerce a numeric value
[1] 3

And we can parse a string for decimal values in much the same way.
 
>	as.integer("5.27") # coerce a decimal string [1] 5

On the other hand, it is erroneous trying to parse a non-decimal string.

>	as.integer("Joe") # coerce an non−decimal string
[1] NA
Warning message:
NAs introduced by coercion

Often, it is useful to perform arithmetic on logical values. Like the C language, TRUE has the value 1, while FALSE has value 0.

>	as.integer(TRUE)	# the numeric value of TRUE [1] 1
>	as.integer(FALSE) # the numeric value of FALSE [1] 0
Complex:

complexvalue in R is defined via the pure imaginary value i.

>	z = 1 + 2i	# create a complex number
>	z	# print the value of z [1] 1+2i
>	class(z)	# print the class name of z [1] "complex"

The following gives an error as −1 is not a complex value.

>	sqrt(−1)	# square root of −1
[1] NaN
Warning message:
In sqrt(−1) : NaNs produced

Instead, we have to use the complex value −1 + 0i.

>	sqrt(−1+0i)	# square root of −1+0i
[1] 0+1i

An alternative is to coerce −1 into a complex value.

>	sqrt(as.complex(−1))
[1] 0+1i

Logical:

A logical value is often created via comparison between variables.

>	x = 1; y = 2 # sample values
>	z = x > y	# is x larger than y?
 
>	z	# print the logical value
[1] FALSE
>	class(z)	# print the class name of z
[1] "logical"

Standard logical operations are "&" (and), "|" (or), and "!" (negation).

>	u = TRUE; v = FALSE
>	u & v	# u AND v
[1] FALSE
>	u | v	# u OR v
[1] TRUE
>	!u	# negation of u
[1] FALSE

Character:

A character object is used to represent string values in R. We convert objects into character values with the as.character() function:

>	x = as.character(3.14)
>	x	# print the character string
[1] "3.14"
>	class(x)	# print the class name of x
[1] "character"

Two character values can be concatenated with the paste function.

>	fname = "Joe"; lname ="Smith"
>	paste(fname, lname) [1] "Joe Smith"

However, it is often more convenient to create a readable string with the sprintf function, which has a C language syntax.

>	sprintf("%s has %d dollars", "Sam", 100) [1] "Sam has 100 dollars"

To extract a substring, we apply the substr function. Here is an example showing how to extract the substring between the third and twelfth positions in a string.


>	substr("Mary has a little lamb.", start=3, stop=12) [1] "ry has a l"

And to replace the first occurrence of the word "little" by another word "big" in the string, we apply the sub function.

>	sub("little", "big", "Mary has a little lamb.")
[1] "Mary has a big lamb."
 
Vector:
A vector is a sequence of data elements of the same basic type. Members in a vector are officially called components. Nevertheless, we will just call them members in this site.

Here is a vector containing three numeric values 2, 3 and 5.

>	c(2, 3, 5)
[1] 2 3 5

And here is a vector of logical values.

>	c(TRUE, FALSE, TRUE, FALSE, FALSE)
[1] TRUE FALSE TRUE FALSE FALSE

A vector can contain character strings.

>	c("aa", "bb", "cc", "dd", "ee")
[1] "aa" "bb" "cc" "dd" "ee"

Incidentally, the number of members in a vector is given by the length function.

>	length(c("aa", "bb", "cc", "dd", "ee"))
[1] 5

Combining vectors:

Vectors can be combined via the function c. For examples, the following two vectors n and s are combined into a new vector containing elements from both vectors.

>	n = c(2, 3, 5)
>	s = c("aa", "bb", "cc", "dd", "ee")
>	c(n, s)
[1]	"2" "3" "5" "aa" "bb" "cc" "dd" "ee"


Vector Arithmetic:

Arithmetic operations of vectors are performed member-by-member, i.e., memberwise. For example, suppose we have two vectors a and b.
>	a = c(1, 3, 5, 7)
>	b = c(1, 2, 4, 8)

Then, if we multiply a by 5, we would get a vector with each of its members multiplied by 5.

>	5 * a
[1] 5 15 25 35

And if we add a and b together, the sum would be a vector whose members are the sum of the corresponding members from a and b.
 
>	a + b
[1] 2 5 9 15
Similarly for subtraction, multiplication and division, we get new vectors via memberwise operations.

>	a - b
[1] 0 1 1 -1

>	a * b
[1] 1 6 20 56

>	a / b
[1] 1.000 1.500 1.250 0.875

Recycling Rule

If two vectors are of unequal length, the shorter one will be recycled in order to match the longer vector. For example, the following vectors u and v have different lengths, and their sum is computed by recycling values of the shorter vector u.

>	u = c(10, 20, 30)
>	v = c(1, 2, 3, 4, 5, 6, 7, 8, 9)
>	u + v
[1] 11 22 33 14 25 36 17 28 39
Vector Index:

We retrieve values in a vector by declaring an index inside a single square bracket "[]" operator.

For example, the following shows how to retrieve a vector member. Since the vector index is 1- based, we use the index position 3 for retrieving the third member.

>	s = c("aa", "bb", "cc", "dd", "ee")
>	s[3]
[1] "cc"

Unlike other programming languages, the square bracket operator returns more than just individual members. In fact, the result of the square bracket operator is another vector, and s[3] is a vector slice containing a single member "cc".

Negative Index

If the index is negative, it would strip the member whose position has the same absolute value as the negative index. For example, the following creates a vector slice with the third member removed.

>	s[-3]
[1] "aa" "bb" "dd" "ee"
 
Out-of-Range Index

If an index is out-of-range, a missing value will be reported via the symbol NA.

>	s[10]
[1] NA

Numeric Index vector:

A new vector can be sliced from a given vector with a numeric index vector, which consists of member positions of the original vector to be retrieved.

Here it shows how to retrieve a vector slice containing the second and third members of a given vector s.

>	s = c("aa", "bb", "cc", "dd", "ee")
>	s[c(2, 3)]
[1] "bb" "cc"

Duplicate Indexes

The index vector allows duplicate values. Hence the following retrieves a member twice in one operation.



>	s[c(2, 3, 3)]
[1] "bb" "cc" "cc"

Out-of-Order Indexes

The index vector can even be out-of-order. Here is a vector slice with the order of first and second members reversed.

>	s[c(2, 1, 3)]
[1] "bb" "aa" "cc"

Range Index

To produce a vector slice between two indexes, we can use the colon operator ":". This can be convenient for situations involving large vectors.

>	s[2:4]
[1] "bb" "cc" "dd"

Logical Index vector:

A new vector can be sliced from a given vector with a logical index vector, which has the same length as the original vector. Its members are TRUE if the corresponding members in the original vector are to be included in the slice, and FALSE if otherwise.

For example, consider the following vector s of length 5.
 
>	s = c("aa", "bb", "cc", "dd", "ee")

To retrieve the the second and fourth members of s, we define a logical vector L of the same length, and have its second and fourth members set as TRUE.

>	L = c(FALSE, TRUE, FALSE, TRUE, FALSE)
>	s[L]
[1] "bb" "dd"

The code can be abbreviated into a single line.

>	s[c(FALSE, TRUE, FALSE, TRUE, FALSE)]
[1] "bb" "dd"

List
A list is a generic vector containing other objects.
For example, the following variable x is a list containing copies of three vectors n, s, b, and a numeric value 3.
List Slicing

We retrieve a list slice with the single square bracket "[]" operator. The following is a slice containing the second member of x, which is a copy of s.
With an index vector, we can retrieve a slice with multiple members. Here a slice containing the second and fourth members of x.
 
 
List Member Reference

In order to reference a list member directly, we have to use the double square bracket"[[]]" operator. The following object x[[2]] is the second member of x. In other words, x[[2]] is a copy of s, but is not a slice containing s or its copy.


We can modify its content directly.


Data Frame
A data frame is used for storing data tables. It is a list of vectors of equal length. For example, the following variable dfis a data frame containing three vectors n, s, b.
Build-in Data Frame

We use built-in data frames in R for our tutorials. For example, here is a built-in data frame in R, called mtcars.
The top line of the table, called the header, contains the column names. Each horizontal line afterward denotes a data row, which begins with the name of the row, and then followed by the actual data. Each data member of a row is called a cell.
 
To retrieve data in a cell, we would enter its row and column coordinates in the single square bracket "[]" operator. The two coordinates are separated by a comma. In other words, the coordinates begins with row position, then followed by a comma, and ends with the column position. The order is important.
Here is the cell value from the first row, second column of mtcars.
 
Moreover, we can use the row and column names instead of the numeric coordinates.

Lastly, the number of data rows in the data frame is given by the nrowfunction.

And the number of columns of a data frame is given by the ncolfunction.

Further details of the mtcarsdata set is available in the R documentation.
>	help(mtcars)	
Instead of printing out the entire data frame, it is often desirable to preview it with the head function beforehand.
